{"componentChunkName":"component---src-templates-blog-post-js","path":"/DataStructure/백트래킹/","result":{"data":{"site":{"siteMetadata":{"title":"DABI_devlog","author":"[DABIN SEO]","siteUrl":"https://Dabinnny.github.io","comment":{"disqusShortName":"","utterances":"Dabinnny/Dabinnny.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"4c3d3b98-9aa5-5ba3-a241-77762208b819","excerpt":"백트래킹은 해를 찾기 위해 후보군에 제약 조건을 점진적으로 체크하다가 해당 후보군이 제약 조건을 만족할 수 없다고 판단되는 즉시 backtrack (다시는 이 후보군을 체크하지 않을 것을 표기)하고 바로 다른 후보군으로 넘어가는 기법으로 결국 최적의 해를 찾는 방법이라고  할 수 있다.   실제 구현시 고려할 수 있는 모든 경우의 수 (후보군)를 상태공간트리(State Space Tree)를 통해 표현하고, 각 후보군을  방식으로 확인한다.   Promising…","html":"<br/>\n<p>백트래킹은 해를 찾기 위해 후보군에 제약 조건을 점진적으로 체크하다가 해당 후보군이 제약 조건을 만족할 수 없다고 판단되는 즉시<br>\n<strong>backtrack (다시는 이 후보군을 체크하지 않을 것을 표기)하고 바로 다른 후보군으로 넘어가는 기법</strong>으로 결국 최적의 해를 찾는 방법이라고<br>\n할 수 있다.  </p>\n<br/>\n<p>실제 구현시 고려할 수 있는 모든 경우의 수 (후보군)를 상태공간트리(State Space Tree)를 통해 표현하고, 각 후보군을 <code class=\"language-text\">DFS</code> 방식으로 확인한다.  </p>\n<blockquote>\n<p>Promising: 해당 루트가 조건에 맞는지를 검사하는 기법<br>\nPruning (가지치기): 조건에 맞지 않으면 포기하고 다른 루트로 바로 돌아서서, 탐색의 시간을 절약하는 기법 </p>\n</blockquote>\n<br/>\n<br/>\n<p>즉, 백트래킹은 트리 구조를 기반으로 DFS로 깊이 탐색을 진행하면서 <strong>각 루트에 대해 조건에 부합하는지 체크(Promising)</strong>하고,<br>\n만약 해당 트리(나무)에서 <strong>조건에 맞지않는 노드는 더 이상 DFS로 깊이 탐색을 진행하지 않고 가지를 치는 과정(Pruning)</strong>이다.  </p>\n<br/>\n<br/>\n<p>아래 상태 공간 트리(문제 해결 과정의 중간 상태를 각각의 노드로 나타낸 트리)를 봐보자.  </p>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/164390368-612d29d9-e824-476a-b125-f0b18f66045d.png\" width=\"450\"> </div>   \n<p>조건이 홀수를 찾는 것이라고 했을때, a는 홀수이고 b, c, d를 점진적으로 탐색을 할때 b는 홀수가 아닌것으로 확인되면<br>\nb와 연결된 e, f, g등이 홀수여도 상관없이 b 아래 트리 노드들은 전체 다 탐색을 진행하지 않고 c로 넘어가 계산의 양을 줄인다.</p>\n<br/>\n<h2 id=\"baekjoon-9663-n-queen\" style=\"position:relative;\"><a href=\"#baekjoon-9663-n-queen\" aria-label=\"baekjoon 9663 n queen permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Baekjoon 9663] N-Queen</h2>\n<p><a href=\"https://www.acmicpc.net/problem/9663\">문제 바로가기</a>  </p>\n<br/>\n<p><strong>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</strong><br>\n<strong>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</strong></p>\n<p><strong>1. 입력  : 첫째 줄에 N이 주어진다. (1 ≤ N &#x3C; 15)</strong></p>\n<p><strong>2. 출력  : 첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.</strong></p>\n<br/>\n<h3 id=\"문제-접근\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A0%91%EA%B7%BC\" aria-label=\"문제 접근 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 접근</h3>\n<p>퀸은 아래와 같이 이동할 수 있으므로, 다음 예와 같이 배치해야 한다.  </p>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/164391255-e8d9e534-fe9c-420c-ab6d-13ea51d39bf2.png\"> </div> \n<br/>\n<br/>\n<br/>\n<p>여기서 <strong>Pruning(가지치기)</strong>은 아래와 같이 맨 위의 행부터 전체 행까지 퀸의 배치가 가능한 경우의 수를 상태 공간 트리 형태로 만든 후 각 경우를<br>\n맨 위의 행부터 DFS 방식으로 접근하고 해당 경우가 진행이 어려울 경우 더 이상 진행하지 않고 다른 경우를 체크하는 방식으로 진행한다.  </p>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/164392530-866a2ee6-cf03-4791-8e7d-03ec91082186.png\"> </div>   \n<br/>  \n<br/>\n<br/>\n<p>탐색은 <strong>Promising(해당 루트가 조건에 맞는지를 검사)</strong>을 통해 확인한다.<br>\n현재까지 앞선 행에서 배치한 퀸이 이동할 수 없는 위치가 있는지를 다음과 같은 조건으로 확인할 수 있는데,<br>\n한 행에 어차피 하나의 퀸만 배치 가능하므로 수평 체크는 별도로 필요하지 않다.  </p>\n<p>즉, 뒤의 좌표값이 같다는 것은 퀸의 이동에 걸린다는 것으로 수직을 체크할 수 있는것 맨 위의 행부터 퀸을 놓고,<br>\n그 다음 퀸이 놓인 상태에서 그 다음행에 퀸을 놓는것이다.  </p>\n<p>이때 퀸의 위치를 조건에 맞게 어떻게 놓을지는 <strong>수직/대각선체크</strong>를 하면 된다.<br>\n수직체크는 열의 뺄셈 값만 보면 되는 것이고, 대각선체크는 열의 차와 행의 차가 같은지를 확인하면 된다.</p>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/164393316-11aa44c1-35fc-4a3e-95d3-8cfd76b1d1c0.png\"> </div> \n<br/>  \n<br/>\n<h3 id=\"구현-코드\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C\" aria-label=\"구현 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구현 코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">promising</span><span class=\"token punctuation\">(</span>candidate<span class=\"token punctuation\">,</span> current_col<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\">#가지치기 (현재까지 배치된 퀸의 정보, 현재 열의 정보) -> 수직/대각선 체크 실시</span>\n    current_row <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>candidate<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> queen_row <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>current_row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>    \n        <span class=\"token keyword\">if</span> candidate<span class=\"token punctuation\">[</span>queen_row<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> current_col <span class=\"token keyword\">or</span> <span class=\"token builtin\">abs</span><span class=\"token punctuation\">(</span>candidate<span class=\"token punctuation\">[</span>queen_row<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> current_col<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> current_row <span class=\"token operator\">-</span> queen_row<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n<span class=\"token comment\">#(체스판 개수, 현재 행의 정보, 지금까지 배치된 퀸의 위치 정보, 전체 배치 정보)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">DFS</span><span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">,</span> current_row<span class=\"token punctuation\">,</span> current_candidate<span class=\"token punctuation\">,</span> final_result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  \n    <span class=\"token keyword\">if</span> current_row <span class=\"token operator\">==</span> N<span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 조건에 맞게 퀸의 배치가 다 끝났다면</span>\n        final_result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current_candidate<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#얇은 복사</span>\n        <span class=\"token keyword\">return</span>\n    \n    <span class=\"token comment\">#탐색을 더 해야하는 중간 행일 경우에는 </span>\n    <span class=\"token keyword\">for</span> candidate_col <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> promising<span class=\"token punctuation\">(</span>current_candidate<span class=\"token punctuation\">,</span> candidate_col<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> \n            current_candidate<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>candidate_col<span class=\"token punctuation\">)</span>\n            DFS<span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">,</span> current_row <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> current_candidate<span class=\"token punctuation\">,</span> final_result<span class=\"token punctuation\">)</span>\n            current_candidate<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">#몇개의 체스판? 이 함수를 순서상 첫번째로 작성해서 틀을 만들어야 한다.</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">solve_n_queens</span><span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  \n    final_result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    DFS<span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> final_result<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> final_result\n\nsolve_n_queens<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>  \n<span class=\"token comment\"># [[1, 3, 0, 2], [2, 0, 3, 1]]</span></code></pre></div>\n<br/>  \n<br/>\n<br/>  \n<br/>\n<blockquote>\n<p>이 글은 패스트캠퍼스 알고리즘 강의를 참고하였습니다.</p>\n</blockquote>","frontmatter":{"title":"백트래킹(Backtracking) 이해하기","date":"April 21, 2022"}}},"pageContext":{"slug":"/DataStructure/백트래킹/","previous":{"fields":{"slug":"/Database/s1/"},"frontmatter":{"title":"[programmers] 있었는데요 없었습니다 (JOIN)"}},"next":null}},"staticQueryHashes":["3128451518","635777304"]}