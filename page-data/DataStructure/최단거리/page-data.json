{"componentChunkName":"component---src-templates-blog-post-js","path":"/DataStructure/최단거리/","result":{"data":{"site":{"siteMetadata":{"title":"DABI_devlog","author":"[DABIN SEO]","siteUrl":"https://Dabinnny.github.io","comment":{"disqusShortName":"","utterances":"Dabinnny/Dabinnny.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"b3b7503e-b7d9-53d2-bfe3-d88e241c01b3","excerpt":"🔍 단일 출발 최단 경로 구하기 가중치 그래프 (Weighted Graph) 에서 간선 (Edge)의 가중치 합이 최소가 되도록 하는 경로를 찾는 것이 목적이다.   첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드 간의 거리부터 먼저 계산하면서  첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트를 해준다.   구현 과정을 살펴보자!…","html":"<h1 id=\"-단일-출발-최단-경로-구하기\" style=\"position:relative;\"><a href=\"#-%EB%8B%A8%EC%9D%BC-%EC%B6%9C%EB%B0%9C-%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\" 단일 출발 최단 경로 구하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🔍 단일 출발 최단 경로 구하기</h1>\n<br/>\n<p>가중치 그래프 (Weighted Graph) 에서 간선 (Edge)의 가중치 합이 최소가 되도록 하는 경로를 찾는 것이 목적이다.  </p>\n<p>첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드 간의 거리부터 먼저 계산하면서<br>\n첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트를 해준다.  </p>\n<p>구현 과정을 살펴보자!</p>\n<h2 id=\"1-우선순위-큐를-활용한-다익스트라-알고리즘-로직\" style=\"position:relative;\"><a href=\"#1-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A1%9C%EC%A7%81\" aria-label=\"1 우선순위 큐를 활용한 다익스트라 알고리즘 로직 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 우선순위 큐를 활용한 다익스트라 알고리즘 로직</h2>\n<br/>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/160999682-f8ae7925-5abc-4b7d-9b90-a1e356160407.png\" width=\"400\"> </div>  \n<br/>\n<br/>\n<p>위와 같은 그래프가 있다고 할때, 첫노드에서 해당 노드로 가는 거리값의 배열과 우선순위 큐를 활용한다.</p>\n<br/>\n<h3 id=\"1-첫-노드를-기준으로-배열을-선언하여-첫-노드에서-각-노드까지의-거리를-저장\" style=\"position:relative;\"><a href=\"#1-%EC%B2%AB-%EB%85%B8%EB%93%9C%EB%A5%BC-%EA%B8%B0%EC%A4%80%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%84%A0%EC%96%B8%ED%95%98%EC%97%AC-%EC%B2%AB-%EB%85%B8%EB%93%9C%EC%97%90%EC%84%9C-%EA%B0%81-%EB%85%B8%EB%93%9C%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B1%B0%EB%A6%AC%EB%A5%BC-%EC%A0%80%EC%9E%A5\" aria-label=\"1 첫 노드를 기준으로 배열을 선언하여 첫 노드에서 각 노드까지의 거리를 저장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(1) 첫 노드를 기준으로 배열을 선언하여 첫 노드에서 각 노드까지의 거리를 저장</h3>\n<ul>\n<li>초기 첫 노드의 거리는 0, 나머지는 inf(무한대)로 초기화한다.  </li>\n<li>먼저 우선순위 큐에 첫 노드의 큐(첫 노드이름, 첫 노드와의 거리값) 삽입해준다. </li>\n</ul>\n<br/>\n<br/>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/161000076-d9541a71-8005-4fa5-9487-dcaf53efcc99.png\" width=\"700\"> </div>  \n<br/>\n<h3 id=\"2-우선순위-큐에서-추출한-노드를-기반으로-인접한-노드와의-거리-계산\" style=\"position:relative;\"><a href=\"#2-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90%EC%84%9C-%EC%B6%94%EC%B6%9C%ED%95%9C-%EB%85%B8%EB%93%9C%EB%A5%BC-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B3%84%EC%82%B0\" aria-label=\"2 우선순위 큐에서 추출한 노드를 기반으로 인접한 노드와의 거리 계산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(2) 우선순위 큐에서 추출한 노드를 기반으로 인접한 노드와의 거리 계산</h3>\n<ul>\n<li>첫 노드를 시작으로 인접한 노드들에 대해, 첫 노드에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 거리를 비교한다.  </li>\n<li>배열에 저장되어 있는 거리보다, 첫 노드에서 해당 노드로 가는 거리가 더 짧을 경우 배열에 현재 노드의 거리를 업데이트 한다.  </li>\n<li>배열에 해당노드의 거리가 업데이트된 경우, 우선순위 큐에 넣는다.  </li>\n<li>배열에 기록되어있는 거리보다 현재 계산된 거리가 더 클 경우에는, 해당 노드와 인접한 노드간의 거리 계산을 하지 않는다.  </li>\n</ul>\n<br>\n \n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/161001431-afe19fae-1e8a-4a68-a883-959b813971e8.png\" width=\"800\"> </div>  \n<br/>\n<p>최초 첫 노드 이외에 모두 inf(무한대)로 지정해주었기 때문에 첫 노드에 인접한 노드들은 모두 우선순위 큐에 들어가고,<br>\n해당 노드들 각각의 거리값이 배열에 업데이트 된다. </p>\n<br/>\n<h3 id=\"3-위의-과정을-우선순위-큐에-꺼낼-노드가-없을때까지-반복\" style=\"position:relative;\"><a href=\"#3-%EC%9C%84%EC%9D%98-%EA%B3%BC%EC%A0%95%EC%9D%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90-%EA%BA%BC%EB%82%BC-%EB%85%B8%EB%93%9C%EA%B0%80-%EC%97%86%EC%9D%84%EB%95%8C%EA%B9%8C%EC%A7%80-%EB%B0%98%EB%B3%B5\" aria-label=\"3 위의 과정을 우선순위 큐에 꺼낼 노드가 없을때까지 반복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(3) 위의 과정을 우선순위 큐에 꺼낼 노드가 없을때까지 반복</h3>\n<p>이때 우선순위 큐는 MinHeap 방식을 활용해서, 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼내게 된다.<br>\n위 표에서 넣어진 (C, 1), (D, 2), (B, 8) 중 (C, 1) 이 먼저 추출(pop)된다.  </p>\n <br/>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/161002047-f229c6fc-d266-46e8-bbef-3b3de732c7c5.png\" width=\"800\"> </div>  \n<br/>\n<p>현재 배열에서는 A-B의 최단 거리는 8이었지만, A-C-B가 6으로 작기 때문에 이를 배열에 업데이트 해주고 이 값은 우선순위 큐에 넣어진다.<br>\nA-D는 2이고, A-C-D는 3으로 더 길기때문에 D의 거리는 업데이트 되지 않는다.  </p>\n<br/>\n<p>이 후, 우선순위 큐에서 가장 짧은 거리인 (D,2)가 추출되고 지금까지 접근하지 못했던 E와 F의 거리가 계산된다.  </p>\n<br/>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/161002941-2daddb76-3c85-48ab-95db-9daffe7dc869.png\" width=\"800\"> </div> \n<br/>\n<br/>\n<p>인접노드의 거리값 업데이트가 완료되었으니 다음 우선순위 큐에서 짧은거리인 (E,5)를 추출하고 인접 노드의 거리를 계산한다.  </p>\n<br/>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/161003419-36790d7d-c86f-493f-89aa-cad1a00af25e.png\" width=\"800\"> </div>   \n<br/>\n<br/>\n<p>(B,6)는 다른 노드로 가는 루트가 없고, A-A 는 0인데 A-F-A 는 11로 두 경우 다 업데이트 되지 않는다.  </p>\n<br/>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/161003827-47ee0add-a560-4b62-a84a-1be54a5abc87.png\" width=\"800\"> </div>  \n<br/>\n<br/>\n<p>(F,7)처럼 현재 기록되어 있는 배열값이 이미 작은 경우는 인접노드까지의 거리를 계산하지 않고 skip한다.(불필요한 계산 과정을 줄여줌)<br>\n이후 우선순위 큐에 남아있는 노드값이 없다면 기준 노드에서 각각의 노드들까지의 최단거리가 구해진 것이다.  </p>\n<br/>\n<div align=\"center\"><img src=\"https://user-images.githubusercontent.com/90162819/161004397-00588de6-2b5b-407d-a4db-8561fb098a79.png\" width=\"700\"> </div> \n<br/>\n<br/>\n<h2 id=\"2-다익스트라-알고리즘-파이썬-구현-heapq-우선순위-큐-활용\" style=\"position:relative;\"><a href=\"#2-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B5%AC%ED%98%84-heapq-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%ED%99%9C%EC%9A%A9\" aria-label=\"2 다익스트라 알고리즘 파이썬 구현 heapq 우선순위 큐 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 다익스트라 알고리즘 파이썬 구현 (heapq 우선순위 큐 활용)</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">mygraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'A'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'B'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'C'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'D'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'B'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'C'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'B'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'D'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'D'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'E'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'F'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'E'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'F'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'F'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">import</span> heapq\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작노드에서 각 노드까지의 거리를 저장할 딕셔너리 생성하고 inf(무한대)로 초기화</span>\n    distances <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>node<span class=\"token punctuation\">:</span> <span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token string\">'int'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> node <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\"># 그래프의 시작 노드의 거리는 자기 자신으로의 거리이므로 0으로 지정</span>\n    distances<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># 노드와 거리값이 저장될 큐 생성</span>\n    queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># 그래프의 시작 노드와 거리값을 큐에 넣어줌</span>\n    heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>distances<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">while</span> queue <span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 큐에서 최소노드를 꺼내 인접한 노드의 거리(가중치)를 계산하며 업데이트</span>\n        current_distance<span class=\"token punctuation\">,</span> current_vertex <span class=\"token operator\">=</span> heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># 더 짧은 경로가 있다면 계산하지 않고 skip</span>\n        <span class=\"token keyword\">if</span> distances<span class=\"token punctuation\">[</span>current_vertex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> current_distance <span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token comment\"># adjacent(노드이름)과 weight(거리값)</span>\n        <span class=\"token keyword\">for</span> adjacent<span class=\"token punctuation\">,</span> weight <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>current_vertex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            \n            <span class=\"token comment\"># 갱신할 거리는 지나온 가중치값 + 새로 계산할 인접노드 가중치 값</span>\n            distance <span class=\"token operator\">=</span> current_distance <span class=\"token operator\">+</span> weight\n\n            <span class=\"token comment\"># 시작 노드에서 인접노드로 바로 가는것보다 현재 노드를 통해 가는것이 더 가까울 경우 거리 업데이트</span>\n            <span class=\"token keyword\">if</span> distance <span class=\"token operator\">&lt;</span> distances<span class=\"token punctuation\">[</span>adjacent<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distances<span class=\"token punctuation\">[</span>adjacent<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>distance<span class=\"token punctuation\">,</span> current_vertex<span class=\"token punctuation\">]</span>\n                heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>distance<span class=\"token punctuation\">,</span> adjacent<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">return</span> distances\n    \n\ndijkstra<span class=\"token punctuation\">(</span>mygraph<span class=\"token punctuation\">,</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># {'A': 0, 'B': 6, 'C': 1, 'D': 2, 'E': 5, 'F': 6}</span></code></pre></div>\n<br/>\n<p>정점 개수가 V, 간선 개수가 E일 때 기본적인 최적화를 거치면 O(ElogV)의 시간복잡도를 갖는다.</p>\n<br/>\n<br/>\n<blockquote>\n<p><em>이 글은 패스트캠퍼스 알고리즘 강의를 참고하였습니다.</em></p>\n</blockquote>","frontmatter":{"title":"다익스트라(dijkstra) 알고리즘 - 최단 경로 구하기","date":"March 30, 2022"}}},"pageContext":{"slug":"/DataStructure/최단거리/","previous":{"fields":{"slug":"/ETC/jave/"},"frontmatter":{"title":"Mac M1 Konlpy 설치하기 "}},"next":{"fields":{"slug":"/ETC/pandas/"},"frontmatter":{"title":"Mac M1 pandas cpython-38-darwin.so 에러 "}}}},"staticQueryHashes":["3128451518","635777304"]}